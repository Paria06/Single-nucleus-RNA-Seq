# for this DEG analysis the seurat object should be processed, normalized, integrated, clustered, labelled.
# In this analysis the ALS is compared  to normal control in spinal cord region
 
# Load necessay libraries
library(scater)
library(Seurat)
library(scran)
library(tidyverse)
library(cowplot)
library(Matrix.utils)
library(edgeR)
library(dplyr)
library(magrittr)
library(Matrix)
library(purrr)
library(reshape2)
library(S4Vectors)
library(tibble)
library(SingleCellExperiment)
library(pheatmap)
library(png)
library(apeglm)
library(DESeq2)
library(RColorBrewer)
library(ggplot2)
library(UpSetR)
library(muscatWrapper)
library(ggeasy)
library(ComplexHeatmap)
library(muscat)

print("DEG_interac_med_main")
# all the results, table, figures of this analysis are saved in the below directory
outDir <- "/home/paria/scratch/als-project/analysis/ocu_med_sc/rpca/pseudo_bulk_DEG/Interaction_each_region/interaction/ocu_med/main"


print("Bring in Seurat object")
seurat_integrated <- readRDS("/home/paria/scratch/als-project/analysis/ocu_med_sc/rpca/pseudo_bulk_DEG/seurat_integrated.rds")
seurat_integrated$subcluster <- seurat_integrated$cluster_id
seurat_integrated$cluster_id <- seurat_integrated$main
seurat_integrated$main <- NULL

print("Extract raw counts and metadata to create SingleCellExperiment object")
counts <- seurat_integrated@assays$RNA@counts 
metadata <- seurat_integrated@meta.data
# Set up metadata as desired for aggregation and DE analysis
seurat_integrated$cluster_id <- as.factor(seurat_integrated$cluster_id)
seurat_integrated@active.ident <- seurat_integrated$cluster_id
metadata$cluster_id <- factor(seurat_integrated@active.ident)
# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts), 
                           colData = metadata)

# start from single cell experiment object
reducedDim(sce, "umap", withDimnames=TRUE) <- seurat_integrated[['umap']]@cell.embeddings
reducedDim(sce, "pca", withDimnames=TRUE) <- seurat_integrated[['pca']]@cell.embeddings
reducedDim(sce, "TSNE", withDimnames=TRUE) <- seurat_integrated[['TSNE']]@cell.embeddings


# Identify groups for aggregation of counts
groups <- colData(sce)[, c("sample_id", "cluster_id")]

print("define variables as factor")
sce$sample_id <- as.factor(sce$sample_id)
sce$cluster_id <- as.factor(sce$cluster_id)
sce$condition <- as.factor(sce$condition)
sce$chemistry <- as.factor(sce$chemistry)
sce$region <- as.factor(sce$region)
sce$group_id <- as.factor(sce$group_id)
sce$batchlib <- as.factor(sce$batchlib)
sce$PMI <- as.numeric(sce$PMI)
sce$PMI <- scale(sce$PMI)
sce$individual <- as.factor(sce$individual)
sce$sex <- as.factor(sce$sex)
sce$region_condition <- as.factor(sce$region_condition)

print("Named vector of cluster names")
kids <- purrr::set_names(levels(sce$cluster_id))
# Total number of clusters
nk <- length(kids)
# Named vector of sample names
sids <- purrr::set_names(levels(sce$sample_id))
# Total number of samples 
ns <- length(sids)


print("Generate sample level metadata")
## Determine the number of cells per sample
table(sce$sample_id)
## Turn named vector into a numeric vector of number of cells per sample
n_cells <- as.numeric(table(sce$sample_id))
## Determine how to reoder the samples (rows) of the metadata to match the order of sample names in sids vector
m <- match(sids, sce$sample_id)
## Create the sample level metadata by combining the reordered metadata with the number of cells corresponding to each sample.
ei <- data.frame(colData(sce)[m, ], 
                  n_cells, row.names = NULL) %>% 
                select(-"cluster_id")


print("Remove lowly expressed genes which have less than 10 cells with any counts")
#sce <- sce[rowSums(counts(sce) > 1) >= 10, ]
dim(sce)


print("Aggregate the counts per sample_id and cluster_id")
# Subset metadata to only include the cluster and sample IDs to aggregate across
groups <- colData(sce)[, c("cluster_id", "sample_id")]
# Aggregate across cluster-sample groups
pb <- aggregate.Matrix(t(counts(sce)), 
                       groupings = groups, fun = "sum") 

# Not every cluster is present in all samples; create a vector that represents how to split samples
splitf <- sapply(stringr::str_split(rownames(pb), 
                                    pattern = "_",  
                                    n = 2), 
                 `[`, 1)

# Turn into a list and split the list into components for each cluster and transform
pb <- split.data.frame(pb, 
                       factor(splitf)) %>%
        lapply(function(u) 
                set_colnames(t(u), 
                             stringr::str_extract(rownames(u), "(?<=_)[:alnum:]+")))
class(pb)
# Explore the different components of list
str(pb)


# Print out the table of cells in each cluster-sample group
options(width = 100)
table(sce$cluster_id, sce$sample_id)

# Get sample names for each of the cell type clusters
# prep. data.frame for plotting
get_sample_ids <- function(x){
        pb[[x]] %>%
                colnames()
}
de_samples <- map(1:length(kids), get_sample_ids) %>%
        unlist()


# Get cluster IDs for each of the samples
samples_list <- map(1:length(kids), get_sample_ids)
get_cluster_ids <- function(x){
        rep(names(pb)[x], 
            each = length(samples_list[[x]]))
}
de_cluster_ids <- map(1:length(kids), get_cluster_ids) %>%
        unlist()


# Create a data frame with the sample IDs, cluster IDs and condition
gg_df <- data.frame(cluster_id = de_cluster_ids,
                    sample_id = de_samples)
gg_df <- left_join(gg_df, ei[, c("sample_id", "group_id", "condition", "region", "sex", "chemistry", "batchlib", "PMI", "individual", "region_condition")]) 
metadata <- gg_df %>%
        dplyr::select(cluster_id, sample_id, group_id, condition, region, sex, chemistry, batchlib, PMI, individual, region_condition) 
        
metadata        

metadata$cluster_id <- as.factor(metadata$cluster_id)
clusters <- levels(metadata$cluster_id)
clusters

#####################subsetting the individual cluster ####################
print("subsetting the individual cluster")
intgroup_list <- c("condition", "group_id", "region", "chemistry", "batchlib", "individual", "region_condition")
plots_list <- list()
raw_cluster_DEG <- data.frame()
sig_cluster_DEG <- data.frame()
skip_to_next_loop <- FALSE
res <- NULL

for (i in 1:length(clusters)) {
  tryCatch({
#for (i in clusters[1:2]) {
# print the cell type of each iteration    
print(paste("Celltype_", clusters[i]))
    
# Subset the metadata to only one cell type
cluster_metadata <- metadata[which(metadata$cluster_id == clusters[i]), ]
# Assign the rownames of the metadata to be the sample IDs
rownames(cluster_metadata) <- cluster_metadata$sample_id
head(cluster_metadata)
# Subset the counts to only one cluster
counts <- pb[[clusters[i]]]
cluster_counts <- data.frame(counts[, which(colnames(counts) %in% rownames(cluster_metadata))])
# Check that all of the row names of the metadata are the same and in the same order as the column names of the counts in order to use as input to DESeq2
all(rownames(cluster_metadata) == colnames(cluster_counts))        

print("Create DESeq2 object")
dds <- DESeqDataSetFromMatrix(cluster_counts, 
                              colData = cluster_metadata, 
                              design = ~ sex + PMI + batchlib + group_id + group_id:region)


# Transform counts for data visualization
rld <- rlog(dds, blind=TRUE)


print("Plot PCA")
# the problem with this code is solved
for (x in 1:length(intgroup_list)) {
  var_name <- intgroup_list[x]
  PCA_plot <- DESeq2::plotPCA(rld, intgroup = var_name) + geom_label(aes(label = name))
  # Create a label that combines the PCA plot title and the intgroup variable
  label <- paste("PCA Plot (Cluster:", clusters[i], ", Intgroup:", var_name, ")")
  # Add the label to the PCA plot title
  PCA_plot <- PCA_plot + labs(title = label)
  
  plots_list[[paste0(clusters[i], var_name)]] <- PCA_plot
}


dds <- estimateSizeFactors(dds)
keep <- rowSums(counts(dds)>=10)>= 0.9*37   
dds <- dds[keep,]

dds$group_id <- relevel(dds$group_id, ref="con")
dds$region <- relevel(dds$region, ref = "ocu")


print("Running DESeq2")
dds <- DESeq(dds, fitType='local') 


print("compare the group_id levels")

res <- results(dds, contrast=list(c("group_idals.regionmed")))
res <- lfcShrink(dds, contrast =  contrast, res =res, type="ashr")

saveRDS(object = res, file.path(outDir, paste0("/res.rds")))
#saveRDS(object = sce, file.path(outDir, paste0(cluster, "ALS_vs_con_ocu", "/sce.rds")))

res_tbl <- res %>%
        data.frame() %>%
        rownames_to_column(var="gene") %>%
        as_tibble()

res_tbl$cluster_id <- clusters[i]
raw_cluster_DEG <- rbind(raw_cluster_DEG, res_tbl)
write_csv(raw_cluster_DEG, file.path(paste0(outDir, "/1_raw_cluster.csv")))


# Check results output
padj_cutoff <- 0.05
# Subset the significant results
res_tbl <- res %>%
        data.frame() %>%
        rownames_to_column(var="gene") %>%
        as_tibble()

if (!is.data.frame(res_tbl)) {
    res_tbl <- as.data.frame(res_tbl)
  }

sig_res <- dplyr::filter(res_tbl, padj < padj_cutoff) %>%
        dplyr::arrange(padj)


sig_res$cluster_id <- clusters[i]
sig_cluster_DEG <- rbind(sig_cluster_DEG, sig_res)
write_csv(sig_cluster_DEG, file.path(paste0(outDir,file = "/2_sig_cluster.csv")))
 

}, error = function(e) {    cat("Error occurred in iteration", i, "Skipping to the next iteration.\n")
    # You can add additional error handling here if needed.  
  })
}


stop
# Print all pca Plot out to file

pdf_file <- file.path(outDir, "1_Fig_pca_plots.pdf")
pdf(pdf_file, width = 14.84, height = 14.82)

# Loop through the plots and print each one to the PDF
for (plot_name in names(plots_list)) {
  plot <- plots_list[[plot_name]]
  
  # Get the variable name from the plot_name
  var_name <- gsub(paste0(plot_name, fixed = TRUE), "", plot_name)
  
  # Print each individual plot
  print(plot + ggtitle(paste("Cluster:", var_name)))
}

# Close the PDF device to save the file
dev.off()


# nb. of DS genes & % of total by cluster
n_de <- as.vector(table(sig_res$cluster_id))
col_n <-
  as.vector(names(table(sig_res$cluster_id)))
p_de <-
  format(n_de / nrow(sce) * 100, digits = 3)
Pct_DS <-
  cbind.data.frame("cell_ID" = col_n,
                   "n_DS" = n_de,
                   "Pct_DS" = p_de)
write_csv(Pct_DS, file.path(
  paste0(
    outDir,
    "/3_Table_DS_count_Proportion_per_cluster_id.csv"
  )
))


# view top 3 hits in each cluster
top3 <-
  sig_res %>% group_by(cluster_id) %>% arrange(padj) %>% slice_head(n = 3)
top3 <- top3[c(1, 3, 6:7)]
write_csv(top3, file.path(
  paste0(outDir,
         "/4_Table_Top3_DS_per_cluster_id_FDR_5Pct.csv")
))


#upset_plot####
df <-  sig_res[c(1, 3, 6:7)]
write_csv(df, file.path(
  paste0(
    outDir,
    "/5_Table_raw_masterfile_cpm_Freq_DS_stats_FDR_5Pct.csv"
  )
))

de_gs_by_k <- split(df$gene, df$cluster_id)
UpSet_fig <- upset(fromList(de_gs_by_k))


png(
  file.path(
    paste0(outDir, "/2_Fig_MDS_gene-overlap_UpSet.png")
  ),
  width = 15,
  height = 10,
  units = 'in',
  res = 300
)

print(UpSet_fig)
#plot_grid(UpSet_fig, labels = c('A'))
dev.off()


# pull top-8 DS genes across all clusters
top8 <- bind_rows(sig_res) %>%
  top_n(8, dplyr::desc(padj)) %>%
  pull("gene")

# for ea. gene in 'top8', plot t-SNE colored by its expression
# wrapper to prettify reduced dimension plots
.plot_dr <- function(sce, dr, col)
  plotReducedDim(sce, dimred = dr, colour_by = col) +
  guides(fill = guide_legend(override.aes = list(alpha = 1, size = 2))) +
  theme_minimal() + theme(aspect.ratio = 1)

png(
  file.path(
    paste0(outDir, "/3_Fig_top-8_DS_genes_UMAP_colored.png")
  ),
  width = 15,
  height = 10,
  units = 'in',
  res = 300
)
ps <- lapply(top8, function(g)
  .plot_dr(sce, "umap", g) +
    ggtitle(g) + theme(legend.position = "none"))

# arrange plots 
plot_grid(plotlist = ps,
          ncol = 4,
          align = "vh")+
	  theme(legend.text = element_text(size = 3),  # Adjust legend text size
          legend.title = element_text(size = 3))  # Adjust legend title size
dev.off()


print(summary(warnings()))
sessionInfo()

